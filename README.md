# wangCache
this is a distributed cache system based on golang which is named "wang".

Q: 当请求当前缓存服务器时 此服务器本地没有缓存 接着由当前服务器去请求其他节点服务器 当拿回来缓存值后 不应该更新此服务器的本地缓存吗 ？
A: 分布式缓存的目的是不同key缓存在不同的节点上，增加总的吞吐量。如果大家转发请求后，都再备份一次，每台机器上都缓存了相同的数据，就失去意义了。每个节点缓存1G数据，理论上10个节点总共可以缓存10G不同的数据。
当然对于热点数据，每个节点拿到值后，本机备份一次是有价值的，增加热点数据的吞吐量。groupcache的原生实现中，有1/10的概率会在本机存一次。这样10个节点，理论上可以缓存9G不同的数据，算是一种取舍。


Q: 第一步就抽象出接口，感觉不是很好理解。根据这篇文章 https://blog.chewxy.com/2018/03/18/golang-interfaces/ ，是否可以考虑延迟定义接口。即首先定义类型/struct，在会使用到接口的时候再定义接口。
A: 一般抽象出接口是为了扩展性，很多场景下需要优先抽象接口。比如 RPC 通信需要支持不同的编解码方式，那首先想到的是一个支持编解码的结构体需要支持哪些方法，即接口。GeeRPC第一天 服务端与消息编码 在这篇文章中体现了这种思考方式。
我觉得你说的也是有道理的，如果是比较确定的业务，优先 struct，需要扩展时再抽象接口更符合直觉一些。不过对于实现框架的童鞋来说，可扩展性是第一位的，所以一般都会优先设计接口。比如 go-micro 这个微服务框架，所有的参数都是接口类型的，这个框架是完全可插拔的，允许用户替换任意的类，只要 struct 实现了接口就行。


Q: 是不是还没有实现节点异常的处理
A: 仿照的 groupcache 的实现，假定节点是可用的，不包含异常的处理。
   geecache 对一致性没有要求，所以也没有必要。需要异常处理的一般是实现 CAP 理论中的 CP，比如分布式数据库，消息系统等。有节点宕机时，需要重新选举 master 以保证一致性。后续会考虑此类系统的实现。

Q: singleflight部分代码真的太精巧了，看完后大呼过瘾的感觉。wg.Wait()用来阻塞当前的gorotinue，等待第一个调用返回的思想太精巧了。
   但其实这个还是会有问题，就是分布式情况下可能还是会产生并发请求，也就是说如果我们的GeeCache部署在集群上，落到不同pod的请求还是会并发访问数据库。但总得来说可以应付绝大多数场景了。
A: 一般 groupcache 之上，还会再增加一层封装，作为 API 层，上面这一层还会做一定的负载均衡的措施。singleflight 用来应对相同的并发请求是非常有效的。这里实现的是简单版本的。官方也实现了一个版本 x/sync/singleflight，更强大
